chapter5의 네터리브는 전적으로 ‘제네럴’이 없었을 때 만들어진 코드를 제네럴한 상황에 놓아지게 될 때 어떻게 유지보수하면 좋을지에 대한 가이드라인 그리고 타입으로 부터 안전하게 데이터를 전달하고 전파하는 방법에 대한 생각을 작성했다고 생각한다. 이번 챕터를 통해 우리는 타입 컨버젼의 과정에 대해 다시 한번 더 생각해볼 수 있다.

---

## 목적

해당 챕터에서 언급되는 기본 자바스크립트 문법에 대한 자세한 설명을 기록해둡니다. 여기에 기록되었다는 것은 이전에 해당 문법에 대해 잘 알지 못했다는 의미기도 합니다.

---

## 1. 타입 매개변수

Java에서 타입 매개변수(Type Parameter)는 제네릭(Generic) 프로그래밍에서 사용되는 개념으로, 클래스, 인터페이스, 메서드에서 사용할 데이터 타입을 `일반화`하는 데 사용됩니다. 타입 매개변수를 사용하면 코드를 더 유연하고 `재사용 가능`하게 만들 수 있으며, `타입 안정성`(Type Safety)을 제공합니다.

### 타입 매개변수의 기본 개념

- **타입 매개변수**는 클래스나 메서드를 정의할 때 실제 타입을 `나중에 지정할 수 있도록` 하는 플레이스홀더(placeholder)입니다.
- 일반적으로 대문자 한 글자(`T`, `E`, `K`, `V` 등)로 표시되며, 이는 임의의 타입을 나타냅니다.
- 타입 매개변수는 `컴파일 시점에` 실제 타입으로 `대체`됩니다.

### 예제

1. **제네릭 클래스 정의**
    
    ```java
    public class Box<T> {
        private T item;
    
        public void setItem(T item) {
            this.item = item;
        }
    
        public T getItem() {
            return item;
        }
    }
    
    ```
    
    - 여기서 `T`는 타입 매개변수입니다. `Box` 클래스를 생성할 때 실제 타입을 지정할 수 있습니다.
2. **제네릭 클래스 사용**
    
    ```java
    Box<String> stringBox = new Box<>();
    stringBox.setItem("Hello");
    String item = stringBox.getItem(); // "Hello"
    
    Box<Integer> integerBox = new Box<>();
    integerBox.setItem(123);
    int item = integerBox.getItem(); // 123
    
    ```
    
    - `Box<String>`에서 `T`는 `String`으로 대체되고, `Box<Integer>`에서 `T`는 `Integer`로 대체됩니다.
3. **제네릭 메서드 정의**
    
    ```java
    public <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
    
    ```
    
    - 이 메서드는 어떤 타입의 배열도 받아들일 수 있습니다.
4. **제네릭 메서드 사용**
    
    ```java
    Integer[] intArray = {1, 2, 3};
    String[] strArray = {"A", "B", "C"};
    
    printArray(intArray); // 1, 2, 3 출력
    printArray(strArray); // A, B, C 출력
    
    ```
    

### 타입 매개변수의 장점

1. **타입 안정성**: **`컴파일 시점`**에 `타입을 체크`하여 런타임 오류를 줄일 수 있습니다.
2. **코드 재사용**: 하나의 클래스나 메서드를 여러 타입에 대해 사용할 수 있습니다.
3. **형변환 불필요**: 제네릭을 사용하면 명시적인 형변환이 필요 없습니다.

### 주의사항

- **기본 타입 사용 불가**: 타입 매개변수는 참조 타입만 허용합니다. 기본 타입(int, char 등)은 사용할 수 없으며, 대신 래퍼 클래스(Integer, Character 등)를 사용해야 합니다.
- **타입 소거(Type Erasure)**: Java의 제네릭은 컴파일 시점에 타입 정보가 삭제되므로, 런타임에는 타입 정보를 알 수 없습니다.

### 결론

타입 매개변수는 Java에서 제네릭 프로그래밍을 가능하게 하는 핵심 요소로, 코드의 유연성과 안정성을 크게 향상시킵니다. 이를 통해 다양한 타입에 대해 동일한 로직을 적용할 수 있으며, 타입 관련 오류를 컴파일 시점에 잡아낼 수 있습니다.

---

## 2. 다이아몬드 연산자

Java에서 `<>`는 **다이아몬드 연산자(Diamond Operator)**라고 불리며, 제네릭(Generic) 타입을 사용할 때 **타입 추론(Type Inference)을 간소화하는 데 사용**됩니다. 이 연산자는 Java 7에서 도입되었으며, 코드를 더 간결하고 읽기 쉽게 만들어 줍니다.

### 다이아몬드 연산자의 역할

- 제네릭 클래스나 인터페이스를 인스턴스화할 때, 타입 매개변수를 명시적으로 지정하지 않아도 컴파일러가 컨텍스트(context)에서 타입을 추론할 수 있게 합니다.
- 이로 인해 코드의 중복을 줄이고 가독성을 높일 수 있습니다.

### 사용 예제

### Java 7 이전 (다이아몬드 연산자 없음)

```java
List<String> list = new ArrayList<String>();

```

- 여기서 `ArrayList<String>`에서 타입 매개변수 `String`을 두 번 명시해야 했습니다.

### Java 7 이후 (다이아몬드 연산자 사용)

```java
List<String> list = new ArrayList<>();

```

- `*<>`를 사용하면 컴파일러가 왼쪽의 `List<String>`을 보고 `ArrayList`의 타입 매개변수가 `String`임을 추론합니다. [핵심!!]*
- 따라서 타입 매개변수를 중복해서 작성할 필요가 없어집니다.

### 다이아몬드 연산자의 장점

1. **코드 간결성**: 타입 매개변수를 반복해서 작성하지 않아도 되므로 코드가 더 간결해집니다.
2. **가독성 향상**: 불필요한 타입 정보가 제거되어 코드가 더 읽기 쉬워집니다.
3. **타입 안정성**: 컴파일러가 타입을 추론하므로 타입 안정성이 유지됩니다.

### 주의사항

- 다이아몬드 연산자는 **컴파일러의 타입 추론**에 `의존`하므로, 타입 `추론이 불가능한 경우`에는 
`명시적`으로 타입을 지정해야 합니다.
- Java 7 이상에서만 사용 가능합니다. Java 6 이하에서는 지원되지 않습니다.

### 추가 예제

### 제네릭 클래스와 다이아몬드 연산자

```java
public class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

// 사용 예제
Box<String> box = new Box<>(); // 다이아몬드 연산자 사용
box.setItem("Hello");
String item = box.getItem();

```

- `Box<String> box = new Box<>();`에서 `<>`는 `Box<String>`의 타입 매개변수를 추론합니다.

### 제네릭 메서드와 다이아몬드 연산자

```java
public <T> List<T> createList(T element) {
    List<T> list = new ArrayList<>(); // 다이아몬드 연산자 사용
    list.add(element);
    return list;
}

// 사용 예제
List<String> stringList = createList("Hello");
List<Integer> intList = createList(123);

```

- `new ArrayList<>()`에서 `<>`는 메서드의 타입 매개변수 `T`를 추론합니다.

### 결론

`<>` 다이아몬드 연산자는 Java 7부터 도입된 기능으로, 제네릭 타입을 사용할 때 타입 매개변수를 명시적으로 작성하지 않아도 컴파일러가 타입을 추론할 수 있게 해줍니다. 이를 통해 코드의 중복을 줄이고 가독성을 높일 수 있습니다.

---

## 3. 매개변수

"매개변수(Parameter)"는 프로그래밍에서 매우 중요한 개념으로, **메서드, 함수, 클래스, 또는 제네릭 타입 등에 전달되는 입력값**을 의미합니다. 매개변수의 정의는 사용되는 컨텍스트(context)에 따라 조금씩 달라질 수 있습니다. 아래에서 각 컨텍스트별로 매개변수를 설명드리겠습니다.

---

### 1) **메서드 또는 함수에서의 매개변수**

- **정의**: 메서드나 함수를 호출할 때 전달되는 입력값입니다.
- **역할**: 메서드나 함수가 작업을 수행하는 데 필요한 데이터를 제공합니다.
- **예시**:
    
    ```java
    public int add(int a, int b) {
        return a + b;
    }
    
    ```
    
    - 여기서 `a`와 `b`는 메서드의 매개변수입니다.
    - 이 메서드를 호출할 때 `add(3, 5)`와 같이 실제 값(인자, Argument)을 전달합니다.

---

### 2) **제네릭에서의 타입 매개변수**

- **정의**: 제네릭 클래스, 인터페이스, 메서드에서 사용되는 타입을 일반화하기 위한 플레이스홀더(placeholder)입니다.
- **역할**: 제네릭 타입을 사용할 때 실제 타입을 지정할 수 있게 해줍니다.
- **예시**:
    
    ```java
    public class Box<T> {
        private T item;
        public void setItem(T item) { this.item = item; }
        public T getItem() { return item; }
    }
    
    ```
    
    - 여기서 `T`는 타입 매개변수입니다.
    - `Box<String>`에서 `String`은 실제 타입 매개변수입니다.

---

### 3) **생성자에서의 매개변수**

- **정의**: 객체를 생성할 때 생성자에 전달되는 입력값입니다.
- **역할**: 객체의 초기 상태를 설정하는 데 사용됩니다.
- **예시**:
    
    ```java
    public class Person {
        private String name;
        public Person(String name) {
            this.name = name;
        }
    }
    
    ```
    
    - 여기서 `name`은 생성자의 매개변수입니다.
    - `Person person = new Person("John");`에서 `"John"`은 실제 값(인자)입니다.

---

### 4) **람다 표현식에서의 매개변수**

- **정의**: 람다 표현식에서 사용되는 입력값입니다.
- **역할**: 람다 표현식의 로직에 필요한 데이터를 제공합니다.
- **예시**:
    
    ```java
    (a, b) -> a + b;
    
    ```
    
    - 여기서 `a`와 `b`는 람다 표현식의 매개변수입니다.

---

### 5) **매개변수와 인자(Argument)의 차이**

- **매개변수(Parameter)**: 메서드, 함수, 생성자 등에서 정의된 입력값의 이름입니다.
    - 예: `int add(int a, int b)`에서 `a`와 `b`는 매개변수입니다.
- **인자(Argument)**: 메서드, 함수, 생성자 등을 호출할 때 전달되는 실제 값입니다.
    - 예: `add(3, 5)`에서 `3`과 `5`는 인자입니다.

---

### 매개변수의 특징

1. **입력값**: 매개변수는 메서드, 함수, 생성자 등에 전달되는 입력값입니다.
2. **타입 지정**: 매개변수는 타입을 명시해야 합니다 (예: `int`, `String`, `T` 등).
3. **범위(Scope)**: 매개변수는 해당 메서드, 함수, 생성자 내에서만 유효합니다.
4. **필수/선택적**: 일부 언어에서는 매개변수가 필수적이거나 선택적일 수 있습니다 (예: Java에서는 모든 매개변수가 필수적입니다).

---

### 매개변수를 설명하는 방법

매개변수는 다음과 같이 설명할 수 있습니다:

- **"매개변수는 메서드, 함수, 생성자, 또는 제네릭 타입 등에 전달되는 입력값으로, 해당 로직이 작업을 수행하는 데 필요한 데이터를 제공합니다."**
- **"매개변수는 타입을 가지며, 호출 시 실제 값(인자)이 전달됩니다."**

---

### 예제를 통한 이해

```java
// 메서드에서의 매개변수
public int multiply(int x, int y) { // x와 y는 매개변수
    return x * y;
}

// 제네릭에서의 타입 매개변수
public class Container<T> { // T는 타입 매개변수
    private T value;
    public void setValue(T value) { this.value = value; }
    public T getValue() { return value; }
}

// 생성자에서의 매개변수
public class Car {
    private String model;
    public Car(String model) { // model은 매개변수
        this.model = model;
    }
}

```

---

### 결론

매개변수는 프로그래밍에서 **입력값을 전달하고 처리하는 데 사용되는 중요한 개념**입니다. 메서드, 함수, 생성자, 제네릭 등 다양한 컨텍스트에서 사용되며, 각각의 역할과 특징을 이해하는 것이 중요합니다. 매개변수를 올바르게 사용하면 코드의 재사용성과 유연성을 높일 수 있습니다. 😊

---

## 4. 타입

Java 에서 타입은 자료형을 저장하기 위해 표현하는 방식을 의미하기도 한다. 단순한 예로 정수형 타입의 경우 데이터를 받으면 정수부 표현식만 저장하며 각 타입별로 할당된 크기 만큼의 이진 공간을 할당 받는다. 반대로 실수부의 경우 정수부와 달리 소수점을 표현하는 방식. 그리고 그에 따라 데이터를 담을 수 있는 크기 등이 바뀌는 차이점이 있다. Java 에서는 이 데이터를 저장하는 타입에 대해 다양한 방식을 지원하고 있다. 이번 문서에선 해당 종류와 그 차이점에 대해 파악하는 것을 목표로 둔다.

### 1. **매개변수화 타입(Parameterized Type)**

- **정의**: 제네릭 타입에 실제 타입을 지정한 형태입니다.
- **예시**: `List<String>`에서 `List`는 제네릭 타입이고, `String`은 실제 타입 매개변수입니다. 따라서 `List<String>`은 매개변수화 타입입니다.
- **특징**: 컴파일 시점에 타입 안정성을 제공하며, 런타임에는 타입 소거(Type Erasure)가 발생합니다.

매개변수. 즉 전달되는 `입력값`을 의미합니다. 매개변수화 타입이라는 말의 풀이는 다음과 같이 할 수 있다. “String” 타입의 데이터들을 List 처럼 저장할 수 있는 자료형. List<String>

---

### 2. **제네릭 타입(Generic Type)**

- **정의**: 타입 매개변수를 사용하여 일반화된 클래스, 인터페이스, 메서드를 말합니다.
- **예시**: `List<E>`에서 `E`는 타입 매개변수입니다. `List<E>`는 제네릭 타입이지만, 아직 실제 타입이 지정되지 않은 상태입니다.
- **특징**: 제네릭 타입은 여러 매개변수화 타입을 정의할 수 있는 틀(template) 역할을 합니다.

---

### 3. **로 타입(Raw Type)**

- **정의**: 제네릭 타입에 실제 타입 `매개변수를 지정하지 않은 형태`입니다. 제네릭이 도입되기 전의 자바 코드와 호환성을 위해 남아 있습니다.
- **예시**: `List`는 로 타입입니다. `List<String>`과 달리 타입 안정성이 없으며, 컴파일러가 경고를 발생시킵니다.
- **특징**: 타입 안정성이 없으므로 사용을 지양해야 합니다.

---

### 4. **비제네릭 타입(Non-Generic Type)**

- **정의**: 제네릭이 도입되기 전의 일반 클래스나 인터페이스를 말합니다. 타입 매개변수를 사용하지 않습니다.
- **예시**: Java 5 이전의 `ArrayList`는 비제네릭 타입입니다.
- **특징**: 타입 안정성이 없으며, 형변환을 직접 해야 합니다.

---

### 5. **와일드카드 타입(Wildcard Type)**

- **정의**: 제네릭 타입에서 알 수 없는 타입을 표현하기 위해 사용됩니다. `?`로 표시하며, 상한 또는 하한을 지정할 수 있습니다.
- **예시**:
    - `List<?>`: 모든 타입을 허용합니다.
    - `List<? extends Number>`: `Number` 또는 그 하위 타입만 허용합니다.
    - `List<? super Integer>`: `Integer` 또는 그 상위 타입만 허용합니다.
- **특징**: 유연성을 제공하지만, 타입 안정성을 유지해야 합니다.

---

### 6. **타입 토큰(Type Token)**

- **정의**: 타입 정보를 런타임에 전달하기 위해 사용되는 클래스 리터럴입니다.
- **예시**: `Class<String>`은 `String` 클래스의 타입 토큰입니다.
- **특징**: 리플렉션(Reflection)과 함께 사용될 때 유용합니다.

---

### 매개변수화 타입 vs. 다른 타입들

- **매개변수화 타입**: 제네릭 타입에 실제 타입을 지정한 형태 (예: `List<String>`).
- **로 타입**: 제네릭 타입에 실제 타입을 지정하지 않은 형태 (예: `List`).
- **비제네릭 타입**: 제네릭을 사용하지 않은 일반 클래스/인터페이스 (예: Java 5 이전의 `ArrayList`).
- **와일드카드 타입**: 알 수 없는 타입을 표현하는 형태 (예: `List<?>`).

---

### 예제를 통한 이해

```java
// 제네릭 타입
class Box<T> {
    private T item;
    public void setItem(T item) { this.item = item; }
    public T getItem() { return item; }
}

// 매개변수화 타입
Box<String> stringBox = new Box<>(); // String이 실제 타입 매개변수

// 로 타입 (사용 지양)
Box rawBox = new Box(); // 타입 안정성 없음

// 와일드카드 타입
Box<?> wildcardBox = new Box<>(); // 모든 타입 허용
Box<? extends Number> numberBox = new Box<>(); // Number 또는 그 하위 타입 허용

```

---

### 결론

- **매개변수화 타입**은 제네릭 타입에 실제 타입을 지정한 형태로, 타입 안정성을 제공합니다.
- 매개변수화 타입 외에도 **로 타입**, **비제네릭 타입**, **와일드카드 타입** 등이 있으며, 각각의 용도와 특징이 다릅니다.
- `Effective Java` Item 26에서는 매개변수화 타입을 사용하여 타입 안정성을 확보하고, 로 타입 사용을 피할 것을 권장합니다.

이해가 되셨나요? 추가로 궁금한 점이 있다면 언제든 질문해주세요! 😊

---

## 5. 와일드카드 타입 / 타입 매개변수

와일드카드 타입(`?`)과 타입 매개변수(`T`, `E`, `K`, `V` 등)는 제네릭 프로그래밍에서 비슷한 목적을 가지고 있지만, 사용 방식과 의미에서 중요한 차이점이 있습니다. 두 개념을 명확히 구분하는 것이 중요합니다. 아래에서 각각의 특징과 차이점을 설명드리겠습니다.

---

### 1) **타입 매개변수(Type Parameter)**

- **정의**: 제네릭 클래스, 인터페이스, 메서드에서 사용되는 **구체적인 타입의 플레이스홀더(placeholder)**입니다.
- **사용 목적**: 제네릭 타입을 정의할 때 사용되며, 실제 타입은 사용 시점에 지정됩니다.
- **특징**:
    - **이름을 가짐**: `T`, `E`, `K`, `V` 등과 같이 이름이 있습니다.
    - **재사용 가능**: 타입 매개변수는 클래스나 메서드 내에서 여러 번 사용될 수 있습니다.
    - **타입 제한 가능**: `extends`나 `super`를 사용하여 타입의 범위를 제한할 수 있습니다.
- **예시**:
    
    ```java
    public class Box<T> {
        private T item;
        public void setItem(T item) { this.item = item; }
        public T getItem() { return item; }
    }
    
    ```
    
    - `T`는 타입 매개변수입니다. `Box<String>`에서 `T`는 `String`으로 대체됩니다.

---

### 2) **와일드카드 타입(Wildcard Type)**

- **정의**: **알 수 없는 타입**을 표현하기 위해 사용되는 기호(`?`)입니다.
- **사용 목적**: 제네릭 타입을 사용할 때 유연성을 제공하며, 특정 타입에 종속되지 않도록 합니다.
- **특징**:
    - **이름이 없음**: `?`로 표현되며, 타입 매개변수와 달리 이름이 없습니다.
    - **단일 사용**: 와일드카드는 한 번만 사용되며, 재사용되지 않습니다.
    - **타입 제한 가능**: `extends`나 `super`를 사용하여 타입의 범위를 제한할 수 있습니다.
- **예시**:
    
    ```java
    public void printList(List<?> list) {
        for (Object item : list) {
            System.out.println(item);
        }
    }
    
    ```
    
    - `List<?>`는 모든 타입의 리스트를 허용합니다.

---

### 3) **와일드카드 타입과 타입 매개변수의 차이점**

| 특징 | 타입 매개변수 (`T`, `E`, 등) | 와일드카드 타입 (`?`) |
| --- | --- | --- |
| **이름** | 이름이 있음 (예: `T`, `E`) | 이름이 없음 (`?`) |
| **사용 범위** | 클래스, 인터페이스, 메서드 전체에서 재사용 가능 | 단일 위치에서만 사용 가능 |
| **타입 제한** | `extends`, `super`로 제한 가능 | `extends`, `super`로 제한 가능 |
| **유연성** | 구체적인 타입을 정의할 때 사용 | 알 수 없는 타입을 표현할 때 사용 |
| **예시** | `Box<T>`에서 `T`는 타입 매개변수 | `List<?>`에서 `?`는 와일드카드 타입 |

---

### 4) **사용 사례 비교**

### 타입 매개변수 사용 예시

```java
public class Box<T> {
    private T item;
    public void setItem(T item) { this.item = item; }
    public T getItem() { return item; }
}

Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");
String item = stringBox.getItem(); // "Hello"

```

- `T`는 타입 매개변수로, `Box<String>`에서 `T`는 `String`으로 대체됩니다.

### 와일드카드 타입 사용 예시

```java
public void printList(List<?> list) {
    for (Object item : list) {
        System.out.println(item);
    }
}

List<String> stringList = Arrays.asList("A", "B", "C");
List<Integer> intList = Arrays.asList(1, 2, 3);

printList(stringList); // A, B, C 출력
printList(intList);    // 1, 2, 3 출력

```

- `List<?>`는 모든 타입의 리스트를 허용합니다. `?`는 와일드카드 타입입니다.

---

### 5) **와일드카드 타입의 확장: 상한과 하한**

와일드카드 타입은 `extends`와 `super`를 사용하여 타입의 범위를 제한할 수 있습니다.

### 상한 와일드카드 (`? extends T`)

- **의미**: `T` 또는 `T`의 하위 타입만 허용합니다.
- **예시**:
    
    ```java
    public void processNumbers(List<? extends Number> list) {
        for (Number num : list) {
            System.out.println(num);
        }
    }
    
    ```
    
    - `List<Integer>`, `List<Double>` 등은 허용되지만, `List<String>`은 허용되지 않습니다.

### 하한 와일드카드 (`? super T`)

- **의미**: `T` 또는 `T`의 상위 타입만 허용합니다.
- **예시**:
    
    ```java
    public void addNumbers(List<? super Integer> list) {
        list.add(123);
    }
    
    ```
    
    - `List<Number>`, `List<Object>` 등은 허용되지만, `List<Double>`은 허용되지 않습니다.

---

### 6) **결론**

- **타입 매개변수**: 제네릭 클래스, 인터페이스, 메서드에서 **구체적인 타입을 정의**할 때 사용됩니다. 이름이 있으며, 재사용이 가능합니다.
- **와일드카드 타입**: **알 수 없는 타입**을 표현할 때 사용됩니다. 이름이 없으며, 단일 위치에서만 사용됩니다. 유연성을 제공합니다.

둘 다 제네릭 프로그래밍에서 타입 안정성을 제공하지만, 사용 목적과 방식에서 차이가 있습니다. 와일드카드 타입은 타입 매개변수보다 더 유연한 코드를 작성할 때 유용합니다. 😊